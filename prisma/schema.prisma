// prisma/schema.prisma

datasource db {
  provider     = "postgresql"
  url          = env("DATABASE_URL") // Renamed from POSTGRES_PRISMA_URL for Prisma convention
  relationMode = "prisma"
}

generator client {
  provider = "prisma-client-js"
}

model Attribute {
  id          String   @id @default(uuid())
  name        String   @unique
  category    String?  @default("Custom")
  description String?
  entity_type String // "person", "event", "place", "reflection", "journal", "all"
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt

  person_attributes PersonAttribute[] @relation("AttributeToPersonAttribute")
  event_attributes  EventAttribute[] @relation("AttributeToEventAttribute")
  place_attributes  PlaceAttribute[] @relation("AttributeToPlaceAttribute")

  @@index([entity_type])
  @@index([name])
  @@index([category])
}

model Person {
  id              String   @id @default(uuid())
  name            String
  email           String?  @unique
  role            String?
  photo_url       String?
  date_of_birth   String? // Consider using DateTime if you store full dates
  place_of_birth  String?
  marital_status  String? // Consider enum: "single", "married", "divorced", "widowed"
  spouse_id       String?
  created_at      DateTime @default(now())
  updated_at      DateTime @updatedAt
  childrenIds     String[] // If these are IDs of other Person records, this needs a proper relation

  attributes      PersonAttribute[]
  memories        MemoryPerson[]
  spouse          Person?           @relation("SpouseRelation", fields: [spouse_id], references: [id], onDelete: Restrict, onUpdate: Restrict)
  spouses         Person[]          @relation("SpouseRelation") // Inverse relation for spouse

  @@index([name])
  @@index([email])
  @@index([spouse_id])
}

model PersonAttribute {
  id         String    @id @default(uuid())
  person_id  String
  attribute  String // Name of the attribute
  value      String
  created_at DateTime  @default(now())
  updated_at DateTime  @updatedAt
  person     Person    @relation(fields: [person_id], references: [id], onDelete: Cascade)
  attribute_definition Attribute? @relation("AttributeToPersonAttribute", fields: [attribute], references: [name])

  @@unique([person_id, attribute])
  @@index([person_id])
  @@index([attribute])
}

model Event {
  id             String           @id @default(uuid())
  title          String
  description    String?
  date           DateTime
  date_type      DateType // "year", "month", "day", "exact" - Not in DB schema, was in TS type
  place_id       String?
  type           String // Consider enum: "meeting", "workshop", "conference", "social", "training"
  capacity       Int?
  created_at     DateTime         @default(now())
  updated_at     DateTime         @updatedAt
  place          Place?           @relation(fields: [place_id], references: [id], onDelete: SetNull)
  attributes     EventAttribute[]
  memories       Memory[]         @relation("EventMemories") // Explicit relation name
  journals       Journal[]        @relation("EventMemories") // Opposite relation for Journal


  @@index([title])
  @@index([date])
  @@index([place_id])
}

model EventAttribute {
  id         String    @id @default(uuid())
  event_id   String
  attribute  String // Name of the attribute
  value      String
  created_at DateTime  @default(now())
  updated_at DateTime  @updatedAt
  event      Event     @relation(fields: [event_id], references: [id], onDelete: Cascade)
  attribute_definition Attribute? @relation("AttributeToEventAttribute", fields: [attribute], references: [name])

  @@unique([event_id, attribute])
  @@index([event_id])
  @@index([attribute])
}

model Place {
  id          String   @id @default(uuid())
  name        String
  address     String?
  city        String
  country     String
  type        String // Consider enum: "office", "restaurant", "hotel", "venue", "park", "museum", "store"
  capacity    Int?
  rating      Float?
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt
  events      Event[]
  attributes  PlaceAttribute[]
  memories    Memory[]  @relation("PlaceMemories") // Explicit relation name
  journals    Journal[] @relation("PlaceMemories") // Add this line for the Journal relation

  @@index([name])
  @@index([city])
  @@index([country])
}

model PlaceAttribute {
  id         String    @id @default(uuid())
  place_id   String
  attribute  String // Name of the attribute
  value      String
  created_at DateTime  @default(now())
  updated_at DateTime  @updatedAt
  place      Place     @relation(fields: [place_id], references: [id], onDelete: Cascade)
  attribute_definition Attribute? @relation("AttributeToPlaceAttribute", fields: [attribute], references: [name])

  @@unique([place_id, attribute])
  @@index([place_id])
  @@index([attribute])
}

model Memory {
  id           String       @id @default(uuid())
  title        String
  description  String?
  media_type   String // "photo", "document"
  media_url    String
  media_name   String
  media_size   Int
  date         DateTime
  date_type    DateType 
  place_id     String?
  event_id     String?
  created_at   DateTime     @default(now())
  updated_at   DateTime     @updatedAt


  place        Place?       @relation("PlaceMemories", fields: [place_id], references: [id], onDelete: SetNull)
  event        Event?       @relation("EventMemories", fields: [event_id], references: [id], onDelete: SetNull)
  people       MemoryPerson[] @relation("JournalPeople")
  reflections  Reflection[]

  @@index([title])
  @@index([date])
  @@index([place_id])
  @@index([event_id])
  @@index([media_name])
}

model Journal {
  id           String       @id @default(uuid())
  title        String
  description  String?
  media_type   String // "photo", "document"
  media_url    String
  media_name   String
  media_size   Int
  date         DateTime
  date_type    DateType 
  place_id     String?
  event_id     String?
  created_at   DateTime     @default(now())
  updated_at   DateTime     @updatedAt

  place        Place?       @relation("PlaceMemories", fields: [place_id], references: [id], onDelete: SetNull)
  event        Event?       @relation("EventMemories", fields: [event_id], references: [id], onDelete: SetNull)
  people       MemoryPerson[] @relation("JournalPeople")
  reflections  Reflection[] @relation("JournalReflections")

  @@index([title])
  @@index([date])
  @@index([place_id])
  @@index([event_id])
  @@index([media_name])
}

model MemoryPerson {
  memory_id   String
  person_id   String
  journal_id  String?
  created_at  DateTime @default(now())

  memory      Memory   @relation("JournalPeople", fields: [memory_id], references: [id], onDelete: Cascade)
  journal     Journal? @relation("JournalPeople", fields: [journal_id], references: [id], onDelete: Cascade)
  person      Person   @relation(fields: [person_id], references: [id], onDelete: Cascade)

  @@id([memory_id, person_id])
  @@index([memory_id])
  @@index([person_id])
  @@index([journal_id])
}
model Reflection {
  id         String   @id @default(uuid())
  memory_id  String
  journal_id String?
  title      String
  content    String
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  memory     Memory   @relation(fields: [memory_id], references: [id], onDelete: Cascade)
  journal    Journal? @relation("JournalReflections", fields: [journal_id], references: [id], onDelete: Cascade)

  @@index([memory_id])
  @@index([title])
  @@index([journal_id])
  @@index([memory_id, created_at(sort: Desc)])
  @@index(map: "idx_reflections_content_search", fields: [content]) // Assuming you want full-text search, adjust as needed
  @@index(map: "idx_reflections_title_search", fields: [title])   // Assuming you want full-text search, adjust as needed
}



enum EntityType {
  PERSON
  EVENT
  PLACE
  REFLECTION
  JOURNAL
  ALL
}

enum DateType {
  year
  month
  day
  exact
}

// Tables from SQL scripts not directly represented in TS types:
// - migrations (usually handled by Prisma or other migration tools)